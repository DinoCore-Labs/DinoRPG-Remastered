import { DinozFiche } from '../models/dinoz/dinozFiche.js';
import { levelList } from '../models/dinoz/dinozLevel.js';
import { DinozForMaxXp } from '../models/dinoz/dinozXP.js';
import { raceList } from '../models/dinoz/raceList.js';
import { DinozStatusId } from '../models/dinoz/statusList.js';
import { Stat } from '../models/enums/SkillStat.js';
import { placeList } from '../models/place/placeList.js';
import { BaseSpecialStats, SpecialStat } from '../models/skills/getSpecialStats.js';
import { Skill, skillList } from '../models/skills/skillList.js';
import { ExpectedError } from '../models/utils/expectedError.js';
import { operatorProcess } from '../models/utils/operatorProcess.js';

export const getRace = (raceId: number) => {
	const race = Object.values(raceList).find(r => r.raceId === raceId);

	if (!race) {
		throw new ExpectedError(`Race ${raceId} doesn't exist.`);
	}

	return race;
};

export const getMaxXp = (dinoz: DinozForMaxXp): number => {
	const level = levelList.find(l => l.id === dinoz.level);
	if (!level) throw new Error(`Level ${dinoz.level} doesn't exist.`);

	if (dinoz.status.some(s => s.statusId !== DinozStatusId.BROKEN_LIMIT_3) && dinoz.level === 70) return 0;
	if (dinoz.status.some(s => s.statusId !== DinozStatusId.BROKEN_LIMIT_2) && dinoz.level === 60) return 0;
	if (dinoz.status.some(s => s.statusId !== DinozStatusId.BROKEN_LIMIT_1) && dinoz.level === 50) return 0;

	return level.experience;
};

export type HasPlaceId = { placeId: number };

export const actualPlace = (dinoz: HasPlaceId) => {
	const place = Object.values(placeList).find(p => p.placeId === dinoz.placeId);

	if (!place) {
		throw new Error(`Place ${dinoz.placeId} doesn't exist.`);
	}

	return place;
};

/**
 * @summary Calculate the XP before bonus for a PvP fight
 * @param opponentLevel Level of the opponent
 * @param dinozLevel Level of the Dinoz that fought the opponent
 * @returns The experience the Dinoz is entitled to receive before bonuses
 */
export const calculatePvPxp = (opponentLevel: number, dinozLevel: number) => {
	const BASE_PVP_XP = 50;
	const XP_BASE = 1.2;
	const XP_ADD = 0.8;
	const PVP_COEF = 2.5;

	// Factor based on the level difference
	const levelDiff = (opponentLevel - dinozLevel) / opponentLevel;
	// XP result solely base on the level difference
	const xpFactor = XP_BASE + XP_ADD * levelDiff;
	let xp;
	if (xpFactor < 1) {
		// If the experience  factor based on the level difference too low (i.e Dinoz level is higher than its opponents), then default to a formula based on the opponents level.
		xp = PVP_COEF * opponentLevel;
	} else {
		// Else the opponent's level is equal or higher than the Dinoz, then apply the PVP coef and opponent level to the xp factor based on the level difference.
		xp = xpFactor * PVP_COEF * opponentLevel;
	}

	// Set the minimum to the BASE PVP
	return Math.max(xp, BASE_PVP_XP);
};

/**
 * @summary Calculate the XP before bonus for a PvE fight
 * @param totalMonsterXp Total xp generated by the monsters
 * @param dinozLevel Level of the Dinoz
 * @param maxLevel Maximum achievable level
 * @param initialMaxLevel First max level limit in the game
 * @returns The experience the Dinoz is entitled to receive before bonuses
 */
export const calculatePvExp = (
	totalMonsterXp: number,
	dinozLevel: number,
	maxLevel: number,
	initialMaxLevel: number
) => {
	const XP_BASE = 1.2;
	const XP_ADD = 0.8;
	// Minimum factor applie to the total monster xp
	const MINIMUM_XP_FACTOR = 1.0;
	// Multiplicator constant to increase/decrease result as necessary
	const XP_MULTIPLICATOR = 1.0;

	// Factor based on the level difference
	const levelDiff = (maxLevel - dinozLevel) / maxLevel;

	// XP factor to apply to the total
	let xpFactor = Math.max(XP_BASE + XP_ADD * levelDiff, MINIMUM_XP_FACTOR);

	// Apply new factor when max level limit increases
	if (maxLevel / initialMaxLevel > xpFactor) xpFactor = maxLevel / initialMaxLevel;

	return Math.round(totalMonsterXp * xpFactor * XP_MULTIPLICATOR);
};

// Types "purs" (structurels) : juste ce dont la fonction a besoin
export type DinozSkillLike = {
	skillId: number; // ou Skill si ton enum est accessible dans core
};

export type HasSkillsLike = {
	skills: readonly DinozSkillLike[];
};

export type FollowableDinozLike = {
	id: number;
	placeId: number;
	leaderId: number | null;
	//unavailableReason: unknown | null;
	followers: readonly unknown[];
	skills: readonly DinozSkillLike[];
	life: number;
};

export type PotentialFollowerLike = {
	id: number;
	placeId: number;
	fight: boolean;
	remaining: number;
	skills: readonly DinozSkillLike[];
};

export const getFollowableDinoz = <T extends FollowableDinozLike>(
	dinozList: readonly T[],
	potentialFollower: PotentialFollowerLike
): T[] => {
	// Brave dinoz cannot follow others
	if (potentialFollower.skills.some(s => s.skillId === Skill.BRAVE)) return [];

	return dinozList.filter(dinoz => {
		// Filter out current dinoz
		if (dinoz.id === potentialFollower.id) return false;

		// Filter out unavailable Dinoz (selling, resting...)
		//if (dinoz.unavailableReason !== null) return false;

		// Filter out Dinoz that already have a leader
		if (dinoz.leaderId !== null) return false;

		// Filter out Dinoz that are not in the same place
		if (dinoz.placeId !== potentialFollower.placeId) return false;

		// Filter out brave Dinoz
		if (dinoz.skills.some(s => s.skillId === Skill.BRAVE)) return false;

		// Filter out dead Dinoz
		if (dinoz.life <= 0) return false;

		const maxFollowers = getMaxFollowers(dinoz);

		// Filter out Dinoz that have too many followers
		if (dinoz.followers.length >= maxFollowers) return false;

		return true;
	});
};

export const getMaxFollowers = (dinoz: HasSkillsLike) => {
	let max = BaseSpecialStats[SpecialStat.MAX_FOLLOWERS];

	const skillsAffectingMaxFollowers = Object.values(skillList).filter(skill => skill.effects?.[Stat.MAX_FOLLOWERS]);

	for (const skill of skillsAffectingMaxFollowers) {
		if (dinoz.skills.some(s => s.skillId === skill.id)) {
			const effect = skill.effects?.[Stat.MAX_FOLLOWERS];
			if (effect) {
				max = operatorProcess(max, effect);
			}
		}
	}

	return max;
};

export const orderDinozList = <T extends Pick<DinozFiche, 'id' | 'order' | 'name' | 'leaderId' | 'followers'>[]>(
	dinozList: T
) => {
	const sortedByOrderAndName = [...dinozList].sort((a, b) => {
		if (a.order === null) {
			a.order = a.id;
		}
		if (b.order === null) {
			b.order = b.id;
		}
		if (a.order === b.order) {
			return a.name.localeCompare(b.name);
		}
		return a.order - b.order;
	});

	// Group by leader
	for (const leader of sortedByOrderAndName.filter(dinoz => dinoz.followers.length)) {
		// Find all dinoz that follow this leader
		const followers = sortedByOrderAndName.filter(dinoz => dinoz.leaderId === leader.id);

		// Remove them from the list
		for (const follower of followers) {
			sortedByOrderAndName.splice(
				sortedByOrderAndName.findIndex(dinoz => dinoz.id === follower.id),
				1
			);
		}

		// Add them after the leader
		sortedByOrderAndName.splice(sortedByOrderAndName.findIndex(dinoz => dinoz.id === leader.id) + 1, 0, ...followers);
	}

	return sortedByOrderAndName;
};
